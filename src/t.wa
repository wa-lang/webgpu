// 版权 @2023 凹语言 作者。保留所有权利。

import "webgpu"
import "js"
import "canvas"

func main {
	println("你好，GPU")
}

global obj: js.ExtObj

func TestExtObj() {
	obj = js.NewExtObj()  // obj.handle = 1
    obj.SetMember_i32("i", 42)
    obj.SetMember_string("s", "Hello")

    mo := js.NewExtObj()  // mo.handle = 2
    mo.SetMember_i32("m1", 13)
    mo.SetMember_string("m2", "ff")

    obj.SetMember_obj("o", mo)

    ao := js.NewExtArray() // ao.handle = 3
    ao.Append_i32(1)
    so := js.NewExtObj() // so.handle = 4
    so.SetMember_i32("k", 999)
    ao.Append_obj(so)

    obj.SetMember_obj("a", ao.ExtObj)
}

func TestBytes(t: []u8, s: string) => (string, []u8, []u8) {
    r := make([]u8, len(t)*2)
    for i, v := range t {
        r[i] = v
        r[i + len(t)] = v
    }
    return "Hello", r, []u8(s)
}

func TestCanvas() {
    c, _ := canvas.QueryCanvas("#gpuCanvas")
    ctx, _ := c.GetContext2D()

    //ctx.SetFillStyle("green")
    //ctx.FillRect(0, 0, 50, 50)

    buf := make([]u8, 256*256*4)
    for x := 0; x < 256; x++ {
        for y := 0; y < 256; y++ {
            buf[(y*256+x)*4 + 0] = u8(x)
            buf[(y*256+x)*4 + 1] = u8(x)
            buf[(y*256+x)*4 + 2] = u8(y)
            buf[(y*256+x)*4 + 3] = 255
        }
    }
    ctx.PutImageData(0, 0, 256, 256, buf)
}

//*
const shaderCode = `
struct VertexOut {
  @builtin(position) position : vec4f,
  @location(0) color : vec4f
}

@vertex
fn vertex_main(@location(0) position: vec4f,
               @location(1) color: vec4f) -> VertexOut
{
  var output : VertexOut;
  output.position = position;
  output.color = color;
  return output;
}

@fragment
fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
{
  return fragData.color;
}
`

type Vertex struct {
	x, y, z, w: f32
	r, g, b, a: f32
}

global vertices = [...]Vertex{
	Vertex{ 0.0,  0.6, 0, 1, 1, 0, 0, 1 },
	Vertex{-0.5, -0.6, 0, 1, 0, 1, 0, 1 },
 	Vertex{ 0.5, -0.6, 0, 1, 0, 0, 1, 1},
}

global (
	device: webgpu.Device
	shader: webgpu.ShaderModule
	contex: webgpu.Contex
	vertexBuffer: webgpu.Buffer
	renderPipeline: webgpu.RenderPipeline
)

func InitDevice() {
	device = webgpu.CreateDevice()
}

func InitResource() {
	shader = device.CreateShaderModule(shaderCode)

	contex = webgpu.QueryContex("#gpuCanvas")
	{
		cc := webgpu.ContexConfig{Device: device, Format: webgpu.GetPreferredCanvasFormat(), AlphaMode: webgpu.AlphaMode_premultiplied}
		contex.Configure(cc)
	}

	vertexBuffer = device.CreateBuffer(32 * 3, webgpu.BufferUsage_VERTEX | webgpu.BufferUsage_COPY_DST)
	vertexBuffer.Write(0, raw(vertices[:]))

	vertexAttributes := [...]webgpu.VertexAttribute{
		webgpu.VertexAttribute{Location: 0, Offset: 0, Format: webgpu.VertexFormat_float32x4},
		webgpu.VertexAttribute{Location: 1, Offset: 16, Format: webgpu.VertexFormat_float32x4},
	}
	vertexLayout := webgpu.NewVertexLayout(32, webgpu.BufferStepMode_vertex, vertexAttributes[:])
	pldVertex := webgpu.PipelineDesc_vertex{Module: shader, EntryPoint: "vertex_main"}
	pldVertex.Layouts = append(pldVertex.Layouts, vertexLayout)

	fragTarget := webgpu.NewFragmentTarget(webgpu.GetPreferredCanvasFormat())
	pldFragment := webgpu.PipelineDesc_fragment{Module: shader, EntryPoint: "fragment_main"}
	pldFragment.Targets = append(pldFragment.Targets, fragTarget)

	pipelineDesc := webgpu.NewPipeLineDesc()
	pipelineDesc.SetVertex(pldVertex)
	pipelineDesc.SetFragment(pldFragment)

	renderPipeline = device.CreateRenderPipeline(pipelineDesc)
}

func Draw() {
	colorAttachments := [...]webgpu.RenderPassDesc_ColorAttchment{
		webgpu.RenderPassDesc_ColorAttchment{
			ClearValue: webgpu.Color{0, 0.5, 1.0, 1.0},
			LoadOp: webgpu.LoadOp_clear,
			StoreOp: webgpu.StoreOp_store,
		},
	}
	contexTexture := contex.GetCurrentTexture()
	colorAttachments[0].View = contexTexture.CreateView()

	renderPassDesc := webgpu.NewRenderPassDesc()
	renderPassDesc.SetColorAttachments(colorAttachments[:])

	commandEncoder := device.CreateCommandEncoder()

	renderPass := commandEncoder.BeginRenderPass(renderPassDesc)
	renderPass.SetPipeline(renderPipeline)
	renderPass.SetVertexBuffer(0, vertexBuffer)
	renderPass.Draw(3)
	renderPass.End()

	device.Submit(commandEncoder.Finish())
}  //*/