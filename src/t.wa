// 版权 @2023 凹语言 作者。保留所有权利。

import "webgpu"
import "vec3"
import "matrix"
import "math"
import "math/rand"
import "js"

const (
	CanvasWidth = 512
	CanvasHeight = 512
	uniformBufferSize = 4 * 16
)

func main {
	println("你好，GPU")
	vec3.T()
}

//*
const shaderCode = `
struct Uniforms {
  viewProjectionMatrix : mat4x4f
}
@group(0) @binding(0) var<uniform> uniforms : Uniforms;

@group(1) @binding(0) var<uniform> modelMatrix : mat4x4f;

struct VertexInput {
  @location(0) position : vec4f,
  @location(1) normal : vec3f,
  @location(2) uv : vec2f
}

struct VertexOutput {
  @builtin(position) position : vec4f,
  @location(0) normal: vec3f,
  @location(1) uv : vec2f,
}

@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
  var output : VertexOutput;
  output.position = uniforms.viewProjectionMatrix * modelMatrix * input.position;
  output.normal = normalize((modelMatrix * vec4(input.normal, 0)).xyz);
  output.uv = input.uv;
  return output;
}

@group(1) @binding(1) var meshSampler: sampler;
@group(1) @binding(2) var meshTexture: texture_2d<f32>;

// Static directional lighting
const lightDir = vec3f(1, 1, 1);
const dirColor = vec3(1);
const ambientColor = vec3f(0.05);

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
  let textureColor = textureSample(meshTexture, meshSampler, input.uv);
  //let textureColor = vec4f(1, 0.5, 0.5, 1);

  // Very simplified lighting algorithm.
  let lightColor = saturate(ambientColor + max(dot(input.normal, lightDir), 0.0) * dirColor);

  return vec4f(textureColor.rgb * lightColor, textureColor.a);
}
`

global (
	deviceCreated = false
	device: webgpu.Device

	resourceInitialized = false
	shader: webgpu.ShaderModule
	contex: webgpu.Contex
	renderPipeline: webgpu.RenderPipeline
	depthTexture: webgpu.Texture

	uniformBuffer: webgpu.Buffer
	frameBindGroup: webgpu.BindGroup

	texPlanet, texMoon: webgpu.Texture
	sampler: webgpu.Sampler

	rbs: []Renderable

	renderBundle: webgpu.RenderBundle

	mRotation: f32
)

func StepFrame() {
	if !tryInitDevice() {
		println("Device not ready.")
		return
	}

	tryInitResource()

	draw()
}

func tryInitDevice() => bool {
	if deviceCreated {
		return device.Ready()
	}
	println("Init device...")
	device = webgpu.CreateDevice()
	deviceCreated = true

	rand.Seed(73543197)
	return false
}

#wa:import gpu_sample get_image_bitmap
func jsGetImageBitmap(id: i32) => js.Handle

func tryInitResource() {
	if resourceInitialized {
		return
	}
	resourceInitialized = true
	println("Init resource...")

	contex = webgpu.QueryContex("#gpuCanvas")
	{
		cc := webgpu.ContexConfig{Device: device, Format: webgpu.GetPreferredCanvasFormat(), AlphaMode: webgpu.AlphaMode_premultiplied}
		contex.Configure(cc)
	}

	shader = device.CreateShaderModule(shaderCode)

	// pipeline:
	{
		pipelineDesc := webgpu.NewPipeLineDesc()
		vertexAttributes := [...]webgpu.VertexAttribute{
			webgpu.VertexAttribute{Location: 0, Offset: posOffset, Format: webgpu.VertexFormat_float32x3},  // pos
			webgpu.VertexAttribute{Location: 1, Offset: norOffset, Format: webgpu.VertexFormat_float32x3},  // nor
			webgpu.VertexAttribute{Location: 2, Offset: uvOffset, Format: webgpu.VertexFormat_float32x2},  // uv
		}
		vertexLayout := webgpu.NewVertexLayout(sphereVertexStride, webgpu.BufferStepMode_vertex, vertexAttributes[:])
		pldVertex := webgpu.PipelineDesc_vertex{Module: shader, EntryPoint: "vertexMain"}
		pldVertex.Layouts = append(pldVertex.Layouts, vertexLayout)

		fragTarget := webgpu.NewFragmentTarget(webgpu.GetPreferredCanvasFormat())
		pldFragment := webgpu.PipelineDesc_fragment{Module: shader, EntryPoint: "fragmentMain"}
		pldFragment.Targets = append(pldFragment.Targets, fragTarget)

		depthStencil := webgpu.NewPipelineDesc_depthStencil()
		depthStencil.SetDepthWriteEnabled(true)
		depthStencil.SetDepthCompare(webgpu.DepthCompare_less)
		depthStencil.SetFormat(webgpu.TextureFormat_depth24plus)

		pipelineDesc.SetVertex(pldVertex)
		pipelineDesc.SetFragment(pldFragment)
		pipelineDesc.SetDepthStencil(depthStencil)
		renderPipeline = device.CreateRenderPipeline(pipelineDesc)
	}

	{
		d := webgpu.NewTextureDesc()
		d.SetFormat(webgpu.TextureFormat_depth24plus)
		d.SetSize([]i32{CanvasWidth, CanvasHeight})
		d.SetUsage(webgpu.TextureUsage_RENDER_ATTACHMENT)

		depthTexture = device.CreateTexture(d)
	}

	uniformBuffer = device.CreateBuffer(uniformBufferSize, webgpu.BufferUsage_UNIFORM | webgpu.BufferUsage_COPY_DST)
	{
		entries : []webgpu.BindGroupEntry

		e0 := webgpu.NewBindGroupEntry()
		e0.SetBinding(0)
		e0.SetResource(webgpu.NewBufferBinding(uniformBuffer).ExtObj)
		entries = append(entries, e0)

		bg_desc := webgpu.NewBindGroupDesc()
		bg_desc.SetLayout(renderPipeline.GetBindGroupLayout(0))
		bg_desc.SetEntries(entries)

		frameBindGroup = device.CreateBindGroup(bg_desc)
	}

	// Texture
	{
		texDesc := webgpu.NewTextureDesc()
		texDesc.SetFormat(webgpu.TextureFormat_rgba8unorm)
		texDesc.SetSize([]i32{2048, 1024})
		texDesc.SetUsage(webgpu.TextureUsage_TEXTURE_BINDING | webgpu.TextureUsage_COPY_DST | webgpu.TextureUsage_RENDER_ATTACHMENT)
		texPlanet = device.CreateTexture(texDesc)
		texDesc.SetSize([]i32{512, 256})
		texMoon = device.CreateTexture(texDesc)

		device.CopyExternalImageToTexture(js.WrapExtObj(jsGetImageBitmap(0)), texPlanet)
		device.CopyExternalImageToTexture(js.WrapExtObj(jsGetImageBitmap(1)), texMoon)
	}

	{
		sd := webgpu.NewSamplerDesc()
		sd.SetMagFilter(webgpu.Filter_linear)
		sd.SetMinFilter(webgpu.Filter_linear)

		sampler = device.CreateSampler(sd)
	}

	planet := createSphereRenderable(device, 1.0, 32, 16, 0)
	mat: matrix.Matrix
	mat.Identity()
	planet.bg = createBindGroup(device, renderPipeline, mat, texPlanet)
	rbs = append(rbs, planet)

	asteroids := [...]Renderable{
		createSphereRenderable(device, 0.01, 8, 6, 0.15),
		createSphereRenderable(device, 0.013, 8, 6, 0.15),
		createSphereRenderable(device, 0.017, 8, 6, 0.15),
		createSphereRenderable(device, 0.02, 8, 6, 0.15),
		createSphereRenderable(device, 0.03, 16, 8, 0.15),
	}

	for i := 0; i < 5000; i++ {
		radius := rand.Float32() * 1.7 + 1.25
		angle := rand.Float32() * math.Pi * 2
		x := f32(math.Sin(f64(angle))) * radius
		y := (rand.Float32() - 0.5) * 0.05
		z := f32(math.Cos(f64(angle))) * radius

		r0 := matrix.NewRotateAxis(vec3.Vec3{1, 0, 0}, rand.Float32() * math.Pi)
		r1 := matrix.NewRotateAxis(vec3.Vec3{0, 1, 0}, rand.Float32() * math.Pi)
		t := matrix.NewTranslate(vec3.Vec3{x, y, z})

		r0.Mul(r1)
		r0.Mul(t)
		rb := asteroids[i % len(asteroids)]
		rb.bg = createBindGroup(device, renderPipeline, r0, texMoon)

		rbs = append(rbs, rb)
	}

	rbe_desc := webgpu.NewRenderBundleEncoderDesc()
	rbe_desc.SetColorFormats([]webgpu.TextureFormat{webgpu.GetPreferredCanvasFormat()})
	rbe_desc.SetDepthStencilFormat(webgpu.TextureFormat_depth24plus)
	renderBundleEncoder := device.CreateRenderBundleEncoder(rbe_desc)
	renderScene(renderBundleEncoder)
	renderBundle = renderBundleEncoder.Finish()
}

func draw() {
	matMVP := matrix.NewRotateAxis(vec3.Vec3{0, 1, 0}, mRotation)
	mRotation += 0.001
	rT := matrix.NewRotateAxis(vec3.Vec3{1, 0, 1}, 0.1 * math.Pi)
	matMVP.Mul(rT)

	matView := matrix.NewCameraTransform(vec3.Vec3{0, 0, 4}, vec3.Vec3{0, 0, 0}, vec3.Vec3{0, 1, 0})
	matMVP.Mul(matView)

	matProj := matrix.NewPerspective(2 * math.Pi / 5, 1, 0.5, 100)
	matMVP.Mul(matProj)
	uniformBuffer.Write(0, raw([][4][4]f32{matMVP.M}))
	
	colorAttachments := [...]webgpu.RenderPassDesc_ColorAttchment{
		webgpu.RenderPassDesc_ColorAttchment{
			ClearValue: webgpu.Color{0, 0, 0, 1},
			LoadOp: webgpu.LoadOp_clear,
			StoreOp: webgpu.StoreOp_store,
		},
	}
	contexTexture := contex.GetCurrentTexture()
	colorAttachments[0].View = contexTexture.CreateView()

	depthStencilAttachment := webgpu.RenderPassDesc_DepthStencilAttachment{
		ClearValue: 1.0,
		LoadOp: webgpu.LoadOp_clear,
		StoreOp: webgpu.StoreOp_store,
		View: depthTexture.CreateView(),
	}

	renderPassDesc := webgpu.NewRenderPassDesc()
	renderPassDesc.SetColorAttachments(colorAttachments[:])
	renderPassDesc.SetDepthStencilAttachment(depthStencilAttachment)

	commandEncoder := device.CreateCommandEncoder()
	encoder := commandEncoder.BeginRenderPass(renderPassDesc)

	//renderScene(encoder)
	encoder.ExecuteBundles([]webgpu.RenderBundle{renderBundle})

	encoder.End()
	device.Submit(commandEncoder.Finish())
}

func renderScene(encoder: webgpu.PassEncoder) {
	encoder.SetPipeline(renderPipeline)
	encoder.SetBindGroup(0, frameBindGroup)

	for _, rb := range(rbs) {
		encoder.SetBindGroup(1, rb.bg)
		encoder.SetVertexBuffer(0, rb.vb)
		encoder.SetIndexBuffer(rb.ib, "uint16")
		encoder.DrawIndexed(rb.icount)
	}
}